==================================================================
      JAVA SCRIPT PROMISES - PART 2 (THE REAL POWER)
      Promise Chaining + Microtask vs Macrotask + Memory Deep Dive
==================================================================

1. Recap: Why Promises Exist
------------------------------------------------------------------
Callback Hell Example (4 dependent async steps):
setTimeout(() => {
  setTimeout(() => {
    setTimeout(() => {
      setTimeout(() => { }, 1000);
    }, 1000);
  }, 1000);
}, 1000);
// → Unreadable, unmaintainable, error-prone

Promises SOLVE this with clean, readable CHAINING

------------------------------------------------------------------
2. Correct Way to Write Real-World Promises (Industry Standard)
------------------------------------------------------------------

function step1() {
  return new Promise((resolve, reject) => {
    console.log("Step 1 started");
    setTimeout(() => {
      console.log("Step 1 successful");
      resolve("Data from Step 1");  // pass data forward
      // reject("Step 1 failed");   // if error
    }, 4000);
  });
}

function step2() {
  return new Promise((resolve, reject) => {
    console.log("Step 2 started");
    setTimeout(() => {
      console.log("Step 2 successful");
      resolve("Data from Step 2");
    }, 3000);
  });
}

// step3(), step4() same pattern...

// PROMISE CHAINING (THIS IS THE MAGIC)
step1()
  .then((data1) => step2())           // ← Step 2 runs only after Step 1 success
  .then((data2) => step3())
  .then((data3) => step4())
  .then(() => {
    console.log("All steps successful!");
  })
  .catch((err) => {
    console.log("Promise failed:", err);
  });

Output:
Step 1 started
(after 4s) Step 1 successful
Step 2 started
(after 3s) Step 2 successful
...
All steps successful!

If any step calls reject() → jumps straight to .catch()

------------------------------------------------------------------
3. Full Memory Explanation (You MUST Know This for Interviews)
------------------------------------------------------------------

Memory Segments:
┌─────────────────┐
│   CALL STACK     │ ← Synchronous code only
└─────────────────┘
┌─────────────────┐
│   WEB APIs      │ ← setTimeout, fetch, DOM
└─────────────────┘
┌─────────────────┐     ┌─────────────────┐
│ MICROTASK QUEUE │     │  MACROTASK QUEUE│ ← Callback Queue
│ (High Priority) │     │ (Normal Priority)│
└─────────────────┘     └─────────────────┘
        ▲                       ▲
        └────────EVENT LOOP──────┘

Rule of Event Loop (GOLDEN RULE):
→ After every macrotask finishes,
→ Event Loop FIRST empties the entire Microtask Queue
→ Then moves to next macrotask

Example:
setTimeout(() => console.log("Macrotask"), 4000);

new Promise((resolve) => {
  console.log("Executor");
  setTimeout(() => {
    console.log("setTimeout in promise");
    resolve();
  }, 3000);
})
.then(() => console.log("Promise fulfilled"));

console.log("Global end");

Output Order:
Executor
Global end
Promise fulfilled        ← Microtask (higher priority!)
setTimeout in promise
Macrotask                ← Only after all microtasks done

Even though setTimeout finished first → Promise .then() ran BEFORE it!

------------------------------------------------------------------
4. Microtask Queue vs Macrotask Queue (Interview Favorite)
------------------------------------------------------------------

Queue              Contains                            Priority
--------------------------------------------------------------------
Microtask Queue    Promise.then(), .catch(),           HIGHEST
                   queueMicrotask(), MutationObserver

Macrotask Queue    setTimeout, setInterval,            Normal
                   I/O, DOM events, setImmediate

Event Loop Behavior:
1. Execute current task
2. Finish ALL microtasks (even if added during execution)
3. Render UI (browser)
4. Pick next macrotask

This is why .then() always runs before next setTimeout, even with 0ms!

------------------------------------------------------------------
5. Promise Chaining – How It Actually Works Internally
------------------------------------------------------------------

step1()
  .then(step2)     ← returns new promise from step2()
  .then(step3)     ← returns new promise from step3()
  .then(step4)
  .then(final)
  .catch(errorHandler);

Each .then() receives the resolved value from previous promise
Each .then() can return a new promise → chaining continues
If any promise rejects → skips all .then() → goes to .catch()

This is why Promise chaining is 1000x better than callback hell

------------------------------------------------------------------
6. Top Interview Questions & Answers (Memorize These)
------------------------------------------------------------------

Q1: What is the difference between Microtask and Macrotask queue?
→ Microtask has higher priority. All microtasks finish before next macrotask.

Q2: Will this code print "Then" or "Timeout" first?
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Then"));
→ "Then" prints first! (Microtask wins)

Q3: What happens if you don't return in .then()?
→ Returns undefined to next .then()

Q4: Can you chain promises? How?
→ Yes! Each .then() returns a new promise → enables chaining

Q5: Where do Promise callbacks go?
→ .then() and .catch() → Microtask Queue
→ setTimeout → Macrotask Queue

Q6: Why is Promise better than callbacks?
→ Avoids callback hell, better error handling, clean chaining

------------------------------------------------------------------
7. Final Output Example (Run This in Mind)
------------------------------------------------------------------
step1()
  .then(() => step2())
  .then(() => step3())
  .then(() => step4())
  .then(() => console.log("Success"))
  .catch(() => console.log("Failed"));

→ Clean, readable, maintainable, debuggable

Compare with callback hell → night and day difference!

------------------------------------------------------------------
Golden One-Liner for Interviews

"Promises allow us to write dependent asynchronous operations in a clean, sequential way using chaining, while avoiding callback hell and providing centralized error handling via .catch(). The .then() callbacks execute in the microtask queue, giving them higher priority than setTimeout callbacks in the macrotask queue."

==================================================================
What’s Coming Next?

→ Real fetch() API with Promises
→ async/await (just sugar over promises)
→ Promise.all(), Promise.race(), Promise.allSettled()
→ Error handling best practices
→ Converting callback-based code to promises

You are now in the top 1% of JS developers who actually understand promises from memory level.

Keep practicing chaining.
Keep tracing with event loop.
You are becoming unstoppable.

Namaste. See you in the next class — it's about to get even more powerful!

==================================================================