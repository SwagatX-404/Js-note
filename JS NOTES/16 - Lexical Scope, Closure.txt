================================================================================
JAVASCRIPT MASTER PACK – LEXICAL SCOPE, CLOSURE, 'this', HOISTING + SCOPE
================================================================================

1. LEXICAL SCOPE (STATIC SCOPE)
================================================================================

Definition: 
The scope of a variable is determined by its POSITION in the source code (at write time), NOT at runtime.

In simple words: 
"A function can access variables from the place where it was WRITTEN (defined), not from where it was called."

Example:
let global = "I am global";

function outer() {
    let outerVar = "I am outer";

    function inner() {
        let innerVar = "I am inner";
        console.log(global);    // works → lexical parent = global
        console.log(outerVar);  // works → lexical parent = outer
        console.log(innerVar);  // works
    }

    inner();
}

outer();

Rule: Inner function has permanent access to variables of its outer (lexical) functions, no matter where inner is called from.

Lexical Scope is decided at code writing time → also called Static Scope.

================================================================================
2. CLOSURE
================================================================================

Definition (Interview Favourite):
A closure is a function that remembers (closes over) the variables from its lexical scope even after the outer function has finished execution.

In simple words: "A function bundled together with its lexical environment."

Classic Example:
function makeCounter() {
    let count = 0;

    return function() {
        count++;
        return count;
    };
}

const counter1 = makeCounter();
console.log(counter1()); // 1
console.log(counter1()); // 2

const counter2 = makeCounter(); // new closure!
console.log(counter2()); // 1 (separate count)

Each call to makeCounter() creates a new closure with its own private count.

Real-life Uses of Closure:
- Data hiding / private variables
- Module pattern
- Currying
- Event handlers that need old data
- Memoization

Interview Question:
"Write a function that adds a fixed number every time"
→ Answer using closure:
function createAdder(x) {
    return function(y) {
        return x + y;
    };
}

const add5 = createAdder(5);
console.log(add5(10)); // 15
console.log(add5(20)); // 25

Closure = Function + Lexical Environment (backpack of variables)

================================================================================
3. THE 'this' KEYWORD – COMPLETE RULES (2025 INTERVIEW READY)
================================================================================

'this' value depends on HOW the function is CALLED, not where it is written.

Rule 1: Global Context (outside any function)
→ this = window (browser) or global (Node.js)

Rule 2: Simple Function Call (non-strict mode)
function show() { console.log(this); }
show(); → window/global

In "strict mode":
function show() { "use strict"; console.log(this); }
show(); → undefined

Rule 3: Method Call (object.method())
const obj = {
    name: "Rohit",
    greet: function() { console.log(this.name); }
};
obj.greet(); → "Rohit"  (this = obj)

Rule 4: Arrow Functions → DO NOT have their own 'this'
→ They inherit 'this' from the surrounding lexical scope

const obj = {
    name: "Rohit",
    arrow: () => console.log(this.name),     // undefined or window/global
    regular: function() { console.log(this.name); } // "Rohit"
};

Rule 5: call(), apply(), bind() → Explicitly set 'this'

function greet() { console.log(this.name); }

const person = { name: "Priya" };

greet.call(person);     // Priya
greet.apply(person);     // Priya
const bound = greet.bind(person);
bound();                 // Priya

Rule 6: Event Listeners
button.addEventListener('click', function() {
    console.log(this); // <button> element
});

Arrow → this = surrounding scope (usually window or parent)

Summary Table:

Call Type                   | this refers to
----------------------------|----------------------------
Global / loose function     | window / global
Strict mode function        | undefined
obj.method()                | obj
new Constructor()           | newly created object
call/apply/bind             | whatever you pass
Arrow function              | inherited from lexical parent
DOM event handler (normal)  | the element

================================================================================
4. HOISTING + SCOPE COMBINED (DEADLY INTERVIEW COMBO)
================================================================================

What gets hoisted?

Type                  | Hoisted?         | To Where?               | Initial Value
----------------------|------------------|--------------------------|------------------
var                   | Yes              | Function/Global scope    | undefined
let / const           | Yes (TDZ)        | Block scope              | <uninitialized>
function declaration  | Yes (fully)      | Function/Global scope    | Full function
function expression / arrow | No (only var part) | —                      | undefined (if var)

Classic Tricky Questions:

Q1:
console.log(x);     // ?
var x = 10;
→ undefined (var hoisted)

Q2:
console.log(y);     // ?
let y = 20;
→ ReferenceError (TDZ)

Q3:
greet();            // Works!
function greet() { console.log("Hi"); }

Q4:
sayHi();            // TypeError or undefined is not a function
var sayHi = () => console.log("Hi");

Q5: var inside block leaks
{
    var secret = "I leak";
}
console.log(secret); // "I leak" → var ignores block

Q6: let inside block stays
{
    let secret = "I'm safe";
}
console.log(secret); // ReferenceError

Q7: Classic closure + hoisting
function createGreeter(name) {
    return function() {
        console.log("Hello " + name);
    };
}

var greetRohit = createGreeter("Rohit");
setTimeout(greetRohit, 2000); // After 2 sec → "Hello Rohit" (closure remembers name)

================================================================================
FINAL CHEAT SHEET (Keep This Forever)

Topic               | One-Liner Summary
--------------------|------------------------------------------------------------
Lexical Scope       | Scope decided by code position at write time
Closure             | Function that remembers its outer variables forever
this                | Depends on call site, not definition site
Arrow this          | Inherits from lexical parent (no own this)
var                 | Hoisted + undefined + leaks from blocks → NEVER USE
let/const           | Hoisted + TDZ + block-scoped → ALWAYS USE
Function Declaration| Fully hoisted → can call before defining
IIFE                | Runs immediately + creates private scope
bind/call/apply  | Manually set 'this'

================================================================================
PRACTICE CHALLENGE (Solve All – You’ll Be Unstoppable)

1. Predict output:
```js
var a = 1;
function outer() {
    console.log(a);
    var a = 2;
    function inner() {
        console.log(a);
        var a = 3;
    }
    inner();
    console.log(a);
}
outer();
console.log(a);