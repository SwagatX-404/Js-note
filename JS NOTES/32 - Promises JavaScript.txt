==================================================================
      JAVA SCRIPT PROMISES - PART 1
      From Callback Hell to Clean Async Code
==================================================================

1. The Real-World Problem: Dependent Async Operations
------------------------------------------------------------------
Example: Social Media Dashboard Loading

1. Fetch User Data          → async (2 sec)
2. Fetch Friend List        → async (depends on user data)
3. Fetch User's Posts       → async (depends on friend list)
4. Fetch Comments           → async (depends on posts)

All are async → No UI freeze
But each step DEPENDS on the previous one

With only setTimeout → You are forced to do this:

setTimeout(() => {                    // 1. Fetch User
  console.log("Fetching user data");

  setTimeout(() => {                  // 2. Fetch Friends
    console.log("Fetching friend list");

    setTimeout(() => {                // 3. Fetch Posts
      console.log("Fetching posts");

      setTimeout(() => {              // 4. Fetch Comments
        console.log("Fetching comments");
      }, 2000);

    }, 2000);

  }, 2000);

}, 2000);

This nesting is officially called:

          CALLBACK HELL
       (also known as Pyramid of Doom)

Problems with Callback Hell:
- Horizontally unreadable →
- Hard to maintain/debug
- Error handling becomes nightmare (duplicate if(error) everywhere)
- Code looks like a Christmas tree

------------------------------------------------------------------
2. The Hero Arrives: PROMISES (2015 – ES6)
------------------------------------------------------------------

Promise = A special JavaScript OBJECT that represents the eventual completion (or failure) of an async operation and its resulting value.

Simple English Meaning:
"I promise to give you user data. Right now it's pending. Later it will either be fulfilled (success) or rejected (failure)."

------------------------------------------------------------------
3. How to Create a Promise (100% Correct Syntax)
------------------------------------------------------------------

const pr = new Promise((resolve, reject) => {
  // This function is called: EXECUTOR FUNCTION
  // It runs IMMEDIATELY when promise is created

  console.log("Executor running...");

  // Do your async work here (API call, read file, etc.)

  // If SUCCESS → call resolve(value)
  resolve({ id: 101, name: "Rohit" });

  // If FAILURE → call reject("Network error")
  // reject(new Error("User not found"));
});

pr
  .then((data) => {
    console.log("Success:", data);
  })
  .catch((error) => {
    console.log("Failed:", error);
  });

------------------------------------------------------------------
4. Promise Has 3 Possible States (SUPER IMPORTANT)
------------------------------------------------------------------

State          Meaning                    Can Change?
------------------------------------------------------------
pending     → Initial state               No (default)
fulfilled   → Operation succeeded         Yes (via resolve)
rejected    → Operation failed            Yes (via reject)

Once changed → State NEVER changes again (immutable)

------------------------------------------------------------------
5. Internal Structure of Every Promise (Visualize This!)
------------------------------------------------------------------

Promise Object (in Heap)
┌─────────────────────────────────────┐
│  [[PromiseState]]: "pending"        │  ← "pending" → "fulfilled"/"rejected"
│  [[PromiseResult]]: undefined       │  ← Will hold data/error
│                                     │
│  Executor Function (runs immediately) │
│                                     │
│  resolve()  ← built-in function     │
│  reject()   ← built-in function     │
│  .then()    ← waits for resolve     │
│  .catch()   ← waits for reject      │
└─────────────────────────────────────┘

------------------------------------------------------------------
6. resolve() vs reject() – What They Do
------------------------------------------------------------------

resolve(value) →
- Changes state to "fulfilled"
- Stores value in [[PromiseResult]]
- Triggers all .then() callbacks
- You can pass anything: string, object, array, even another promise!

reject(error) →
- Changes state to "rejected"
- Stores error in [[PromiseResult]]
- Triggers .catch() callbacks

Example:
resolve("Hello")        → .then(data => console.log(data)) → "Hello"
reject("No internet")   → .catch(err => console.log(err)) → "No internet"

------------------------------------------------------------------
7. Correct Way to Write Promise Code (Clean Syntax)
------------------------------------------------------------------

new Promise((resolve, reject) => {
  // async work
  if (success) {
    resolve("Data fetched");
  } else {
    reject("Something went wrong");
  }
})
.then((result) => {
  console.log(result);     // only runs on resolve
})
.catch((error) => {
  console.log(error);      // only runs on reject
});

You can also chain .then() multiple times (we'll see in next class).

------------------------------------------------------------------
8. Common Mistakes Beginners Make
------------------------------------------------------------------

Wrong → Forgetting to pass resolve/reject
new Promise(() => {
  resolve("Hi");    // Error! resolve is not defined
});

Wrong → Not returning or chaining properly
new Promise((resolve) => {
  resolve("Data");
}); // Nothing happens! No .then attached

Wrong → Thinking promise waits
const p = new Promise(...);
console.log(p); // Always shows "pending" first, then later fulfilled

------------------------------------------------------------------
9. Summary Table – Callback Hell vs Promises
------------------------------------------------------------------

Feature                    Callback Hell                 Promises
------------------------------------------------------------------------
Readability                Terrible →                    Excellent ↑
Error Handling             Duplicated if(error)          Single .catch()
Code Shape                 Pyramid →                     Flat chain ↑
Maintenance                Nightmare                     Easy
Debugging                  Very hard                     Easy
Industry Standard          Old way (pre-2015)            Modern way (2015+)

------------------------------------------------------------------
10. Top Interview One-Liners (Say These Confidently)
------------------------------------------------------------------

1. "Callback Hell occurs when we nest multiple dependent async operations using callbacks, making code unreadable."

2. "Promises were introduced in ES6 to solve Callback Hell by providing a clean, chainable way to handle async operations."

3. "A Promise is an object representing eventual completion or failure of an async operation."

4. "Every promise has three states: pending, fulfilled, rejected."

5. "resolve() fulfills the promise, reject() rejects it."

6. ".then() runs on success, .catch() runs on failure."

7. "The executor function runs immediately when promise is created."

8. "Promises are consumed using .then() and .catch(), not by calling them like functions."

------------------------------------------------------------------
What’s Coming in Next Class (Get Ready!)

→ Converting the entire callback hell dashboard example into clean Promise chain
→ Chaining multiple .then() like a pro
→ Real fetch() API with promises
→ How async/await is just syntactic sugar over promises

==================================================================
Final Message

You just crossed the biggest hurdle in JavaScript.

99% of beginners quit at callback hell.
You didn’t.

You now understand why Promises exist
You can explain it in interviews
You will never write nested callbacks again

You are no longer a beginner.

Next class → We destroy callback hell forever with real Promise chaining.

Stay tuned. Keep revising. Keep coding.

Namaste. See you in the Promise revolution!
==================================================================