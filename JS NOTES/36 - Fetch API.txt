==================================================================
      APIs + fetch() – THE BACKBONE OF MODERN WEB DEVELOPMENT
      From Cat Facts to ChatGPT — Everything Runs on This
==================================================================

1. The Greatest Story Ever Told – Why APIs Exist
------------------------------------------------------------------
Sara built a beautiful Cat Fact app on localhost
→ Friends loved it, but couldn’t access from home
→ Solution: HOSTING on AWS/Azure → Gets public IP
→ Problem: IP = 185.34.216.91 → No one remembers numbers
→ Solution: Buy domain → catfact.ninja → Points to IP
→ Now anyone in the world can access

But her friends wanted to use the cat facts in THEIR apps
→ Sara doesn’t want to share her code (hard work!)
→ She creates an API endpoint: https://catfact.ninja/fact
→ Now any app can call this URL → gets a cat fact → without seeing code

This is the entire purpose of APIs:
Expose functionality, NOT code
Like a restaurant menu: You order food, don’t enter the kitchen

Real Examples:
→ ChatGPT API → You get answers, not the 175B parameter model
→ Google Maps API → You get maps, not satellite algorithms
→ Razorpay/Stripe → You get payment, not banking contracts
→ Weather API → You get forecast, not satellite data

90% of modern apps = Stitching APIs together

------------------------------------------------------------------
2. What is an API Endpoint?
------------------------------------------------------------------
Base URL     → https://catfact.ninja
Endpoint     → /fact        → returns 1 random fact
             → /facts       → returns list of facts
             → /breeds      → returns cat breeds

Full URL = Base URL + Endpoint

------------------------------------------------------------------
3. fetch() – The King of APIs in JavaScript
------------------------------------------------------------------
fetch(url) → Always returns a Promise
→ Async by nature (doesn’t block UI)
→ Used to make HTTP requests (GET, POST, etc.)

Basic GET Request:
fetch("https://catfact.ninja/fact")
  .then(response => response.json())   // converts bytes → JS object
  .then(data => console.log(data))
  .catch(err => console.log("API Failed", err));

------------------------------------------------------------------
4. Step-by-Step: What fetch() Actually Returns
------------------------------------------------------------------

Step 1: fetch() → Returns a Response object (NOT the data!)
{
  status: 200,
  ok: true,
  headers: {...},
  body: ReadableStream (raw bytes)
}

Step 2: Convert raw bytes → usable data
response.text()  → returns Promise<string>
response.json()  → returns Promise<JS Object>  ← MOST USED

Best Practice:
fetch(url)
  .then(res => res.json())   // automatically parses JSON
  .then(data => console.log(data.fact))

------------------------------------------------------------------
5. Cleanest Way: async/await + fetch() (Industry Standard)
------------------------------------------------------------------

async function getCatFact() {
  try {
    const response = await fetch("https://catfact.ninja/fact");
    const data = await response.json();  // waits & parses
    console.log(data.fact);
  } catch (error) {
    console.log("API Failed:", error);
  }
}

getCatFact();

This reads like synchronous code → but is fully async!

------------------------------------------------------------------
6. response.json() vs response.text() – Critical Difference
------------------------------------------------------------------

response.text()  → Gives you string (with quotes on keys)
response.json()  → Gives you real JS object (no quotes on keys) ← USE THIS 99%

Example:
{
  "fact": "Cats sleep 16 hours a day",
  "length": 38
}
// vs
{
  fact: "Cats sleep 16 hours a day",
  length: 38
}

Only the second one lets you do: data.fact

------------------------------------------------------------------
7. HTTP Status Codes You Must Know
------------------------------------------------------------------
200 → OK (success)
201 → Created
400 → Bad Request
401 → Unauthorized
403 → Forbidden
404 → Not Found
500 → Server Error

fetch() will go to .then() even on 404!
→ Always check response.ok or response.status

Pro Code:
if (!response.ok) {
  throw new Error(`HTTP ${response.status}`);
}

------------------------------------------------------------------
8. Real-World fetch() Template (Use This Every Time)
------------------------------------------------------------------

async function callAPI() {
  try {
    const res = await fetch("https://api.example.com/data");
    
    if (!res.ok) {
      throw new Error(`Error: ${res.status}`);
    }
    
    const data = await res.json();
    console.log("Success:", data);
    
  } catch (err) {
    console.log("Failed:", err.message);
  }
}

------------------------------------------------------------------
9. Top Interview One-Liners (Say These & Get Hired)
------------------------------------------------------------------

1 "APIs allow apps to use functionality without exposing code — like a restaurant menu."

2 "fetch() returns a Promise that resolves to a Response object, not the actual data."

3 "Always use response.json() to parse JSON — not response.text()."

4 "fetch() does NOT reject on HTTP errors (404, 500) — it still goes to .then()!"

5 "Always check response.ok before calling .json()"

6 "async/await is the modern, readable way to handle fetch() promises."

7 "JSON is the universal data format used by all APIs."

8 "99% of real-world apps are just frontend + multiple APIs stitched together."

------------------------------------------------------------------
10. Free Public APIs to Practice (Bookmark These!)
------------------------------------------------------------------
→ https://catfact.ninja/fact
→ https://dog.ceo/api/breeds/image/random
→ https://api.github.com/users/octocat
→ https://jsonplaceholder.typicode.com/posts
→ https://api.agify.io/?name=Rohit
→ https://api.nationalize.io/?name=Rohit

------------------------------------------------------------------
What’s Coming Next?

→ POST requests with fetch() (send data)
→ Headers, Authorization, Bearer tokens
→ Real login/signup with APIs
→ Loading & error states in UI
→ Building full apps with multiple APIs

==================================================================
Final Message

You just learned the single most important skill in 2025 web development.

Every single app you use daily:
→ Instagram → calls APIs for posts, stories, likes
→ Swiggy → calls APIs for restaurants, cart, payment
→ Spotify → calls APIs for songs, playlists
→ Banking apps → call secure APIs for balance, transfer

You can now talk to ANY of them using fetch() + async/await.

You are no longer just a frontend developer.
You are a full-stack capable developer.

The internet is now your playground.

Next class → We POST data, handle real login, and build something live.

Get ready. The real game begins now.

Namaste. Keep coding. You’re unstoppable.

==================================================================