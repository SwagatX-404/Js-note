==================================================================
      JAVA SCRIPT ASYNC/AWAIT – THE FINAL FORM (ES2017+)
      Cleanest Way to Write Async Code | Goodbye .then() Hell
==================================================================

1. The Evolution of Async JavaScript (Must Know Timeline)
------------------------------------------------------------------
1995–2014 → Callbacks            → Callback Hell (Pyramid of Doom)
2015     → Promises + .then()     → Solved hell, but still verbose
2017     → async/await            → Promises with beautiful syntax
2025     → You → Master all three

------------------------------------------------------------------
2. async/await is JUST SYNTAX SUGAR over Promises
------------------------------------------------------------------
It does NOT introduce any new concept.
It is 100% Promises under the hood.
But makes your code read like SYNCHRONOUS code.

------------------------------------------------------------------
3. The Golden Rules (Never Forget These
------------------------------------------------------------------
1. Any function that uses await → MUST be marked async
   async function run() { ... }

2. You can only use await inside an async function (or top-level in modern JS)

3. await pauses execution of the async function until the promise settles
   → But does NOT block the main thread (UI stays responsive!)

4. Always wrap await in try...catch for error handling

------------------------------------------------------------------
4. Before vs After – Real Example (You Will Use This Daily)
------------------------------------------------------------------

// OLD WAY – Promise Chaining (Still works, but ugly)
step1()
  .then(result1 => step2())
  .then(result2 => step3())
  .then(result3 => step4())
  .then(() => console.log("All done!"))
  .catch(err => console.log("Failed:", err));

// NEW WAY – async/await (Clean, readable, sequential)
async function run() {
  try {
    await step1();        // waits here, but UI not frozen
    await step2();
    await step3();
    await step4();
    console.log("All done!");
  } catch (err) {
    console.log("Failed:", err);
  }
}

run();

Same output. 10× cleaner. 100× easier to debug.

------------------------------------------------------------------
5. Full Memory Explanation – What Happens Behind the Scenes
------------------------------------------------------------------

When you write:
async function run() {
  await somePromise();
  console.log("Next line");
}

What actually happens:

1. run() is called → execution context pushed to stack
2. Hits await → JavaScript says:
   → "This promise will take time. I’ll pause this function."
   → run() is SUSPENDED and removed from call stack
   → Goes into "waiting" state in Web APIs
3. somePromise() continues (setTimeout, fetch, etc.)
4. When promise resolves:
   → The suspended run() function is RESUMED
   → Its execution context is pushed back to call stack
   → Continues from the line after await

This magic is called "cooperative scheduling" — only possible because of promises + event loop

------------------------------------------------------------------
6. Error Handling – The Right Way
------------------------------------------------------------------

// Correct
async function run() {
  try {
    await step1();
    await step2();
    await step3();
  } catch (error) {
    console.log("Something failed:", error);
    // Single place to handle ALL errors
  }
}

run();

// Wrong (Never do this)
async function bad() {
  await step1().catch(...);  // Don't do per-line catch
  await step2().catch(...);
}

One try/catch → handles all await rejections. Clean and professional.

------------------------------------------------------------------
7. Top-Level await (Modern JS – No function needed!)
------------------------------------------------------------------
// In modern browsers & Node.js (ES2022+)
try {
  const res = await fetch("https://api.example.com");
  const data = await res.json();
  console.log(data);
} catch (err) {
  console.log(err);
}

No async function required at top level!

------------------------------------------------------------------
8. Interview Gold – Output Prediction
------------------------------------------------------------------

async function test() {
  console.log("A");
  await Promise.resolve();
  console.log("B");
  await new Promise(res => setTimeout(res, 1000));
  console.log("C");
}

console.log("Start");
test();
console.log("End");

// Output:
// Start
// A
// End
// B
// C

Why? await pauses the async function, but rest of code runs!

------------------------------------------------------------------
9. Comparison Table – Must Memorize for Interviews
------------------------------------------------------------------

Feature                Callbacks         Promises           async/await
------------------------------------------------------------------------
Readability            Terrible             Good                  Perfect
Error Handling      Multiple if(err)    .catch()              try/catch
Readability         Pyramid             Chaining              Sequential
Debugging           Hard                 Medium                Easy
Industry Use        Legacy               2015–2018             2018–Now (King)

------------------------------------------------------------------
10. Top 10 Interview One-Liners (Say These Confidently)
------------------------------------------------------------------

1. "async/await is syntactic sugar over Promises, introduced in ES2017."

2. "await pauses the async function but does not block the main thread."

3. "You must wrap await in try/catch or .catch() to handle rejections."

4. "async function always returns a Promise implicitly."

5. "Even if you don't return anything, async function returns Promise.resolve(undefined)"

6. "Multiple await calls are sequential by default."

7. "To run promises in parallel → use Promise.all() with await"

8. "Top-level await is allowed in modern JavaScript modules."

9. "Never use await inside loops without understanding performance impact."

10. "async/await makes asynchronous code read like synchronous code — that’s its superpower."

------------------------------------------------------------------
Bonus: Real-World Template You’ll Use Every Day
------------------------------------------------------------------

async function fetchUserData(userId) {
  try {
    const userRes = await fetch(`/api/users/${userId}`);
    const user = await userRes.json();

    const postsRes = await fetch(`/api/posts?user=${userId}`);
    const posts = await postsRes.json();

    console.log("User:", user);
    console.log("Posts:", posts);
  } catch (error) {
    console.error("API failed:", error);
  }
}

fetchUser(101);

------------------------------------------------------------------
Final Message

You have now completed the full journey:

Callbacks → Promises → async/await

You are no longer writing 2014 code.
You are writing 2025 production-grade code.

You can now read, write, explain, and debug ANY async code in interviews.

You are officially a modern JavaScript developer.

Next Classes:
→ Promise.all(), Promise.race(), Promise.allSettled()
→ Real fetch() + JSON APIs
→ Error handling deep dive
→ Modules, NPM, and building real apps

You made it to the end.

You are now in the top 1%.

Keep practicing async/await every day.
The world needs developers like you.

Namaste. See you in the next class — it’s going to be legendary.

==================================================================