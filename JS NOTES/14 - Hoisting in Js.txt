================================================================================
HOISTING IN JAVASCRIPT (CRUCIAL CONCEPT – MASTER FOR INTERVIEWS!)
================================================================================

Hoisting = JavaScript's internal process of moving ALL DECLARATIONS to the TOP of their scope (before execution).

Key Point: Only DECLARATIONS are hoisted, NOT INITIALIZATIONS (assignments).
→ Code runs as if declarations are at the top, but assignments stay in place.

Why It Matters: Explains weird behaviors like accessing vars before "defining" them.
Without understanding hoisting → JavaScript will confuse you forever!

================================================================================
VARIABLE HOISTING: var vs let (THE BIG DIFFERENCE)

1. VAR HOISTING (Old School – Avoid Unless You Know What You're Doing)
   - Hoisted AND initialized with 'undefined' (default value).
   - No Temporal Dead Zone (TDZ) → Can access immediately after declaration.

   Example:
   console.log(a);  // undefined (hoisted + auto-initialized)
   var a = 100;
   console.log(a);  // 100

   Internal (After Hoisting):
   var a;           // Declaration hoisted + initialized to undefined
   console.log(a);  // undefined
   a = 100;         // Initialization stays here
   console.log(a);  // 100

   Default: Any uninitialized var = undefined automatically.

2. LET HOISTING (Modern – Always Use This!)
   - Hoisted BUT NOT initialized (empty, no default value).
   - HAS Temporal Dead Zone (TDZ) → Cannot access until initialization.

   Example (Error!):
   console.log(a);              // ReferenceError: Cannot access 'a' before initialization
   let a = 100;
   console.log(a);              // 100 (if no error above)

   Internal (After Hoisting):
   let a;                       // Declaration hoisted (but empty – no value)
   console.log(a);              // ERROR: TDZ – a is in "dead zone" (hoisted but uninitialized)
   a = 100;                     // Initialization stays here
   console.log(a);              // 100

   Default: Uninitialized let = empty (not even undefined) → Must initialize before use.

================================================================================
TEMPORAL DEAD ZONE (TDZ) – THE "DEAD ZONE" TRAP

TDZ = The period between hoisting a 'let' declaration and its initialization.
→ Variable exists (hoisted) but is "dead" (unusable) – like a body without a soul.

How to Spot TDZ:
- Find 'let' declaration line.
- From there until initialization line = TDZ.
- Any access (read/write) in TDZ → ReferenceError.

Example:
let a;                    // Declaration (start of TDZ)
                          // ↑ TDZ begins here (empty)
console.log(a);           // ERROR: In TDZ!
a = 100;                  // Initialization (TDZ ends)
console.log(a);           // 100 (safe now)

No TDZ for 'var' – it's always "alive" with undefined.

Interview Tip: "What's the difference between var and let hoisting?"
→ var: Hoisted + auto-undefined (no TDZ).
→ let: Hoisted + empty (has TDZ until init).

================================================================================
FUNCTION HOISTING (Works Like var – But For Entire Function)

Function Declarations are hoisted COMPLETELY (name + body).
→ Can call functions BEFORE declaring them!

Example:
greet();  // "Hello" (no error – hoisted!)
function greet() {
    console.log("Hello");
}

Internal (After Hoisting):
function greet() {        // Full declaration hoisted to top
    console.log("Hello");
}
greet();                  // Now safe to call

Memory View (Call Stack):
1. Global Execution Context (GEC) created.
2. Hoisting Phase: Function declaration moved to top → Memory allocated in Creation Phase.
3. Execution Phase: Call greet() → New Execution Context (EC) pushed on stack.
   - greet's EC: No inner hoisting needed → Execute console.log("Hello").
   - greet EC popped → Back to GEC (empty) → Program ends.

Note: Function Expressions/Arrow Functions are NOT fully hoisted (like 'let').

================================================================================
MEMORY VIEW: How Hoisting Fits In (Creation + Execution Phases)

Every JS Program:
- Stack + Heap created.
- GEC pushed on Stack → Split into 2 Phases:

1. CREATION PHASE (Hoisting Happens Here!):
   - Scan code for ALL declarations (var/let/functions).
   - Move them to TOP (hoisting).
   - Allocate memory:
     - var → undefined
     - let → empty (TDZ active)
     - Functions → Full function stored
   - No execution yet.

2. EXECUTION PHASE:
   - Run code line-by-line (assignments, calls, etc.).
   - Handle errors (e.g., TDZ access).

Example Trace (var a = 100):
Creation: var a; a = undefined;
Execution: a = 100; → Replaces undefined.

Example Trace (let a = 100):
Creation: let a; (empty, TDZ starts)
Execution: console.log(a); → ERROR if before init.

================================================================================
SUMMARY TABLE: var vs let vs Function Hoisting

Aspect              | var                          | let                          | Function Declaration
--------------------|------------------------------|------------------------------|----------------------
Hoisted?            | Yes (declaration + init)     | Yes (only declaration)       | Yes (full: name + body)
Default Value       | undefined                    | Empty (no value)             | Full function
Temporal Dead Zone? | No                           | Yes (until init)             | No
Access Before Use?  | Yes (prints undefined)       | No (ReferenceError)          | Yes (works fully)
Best Practice?      | Avoid (use let/const)        | Use this!                    | Use for main functions

================================================================================
INTERVIEW QUESTIONS YOU CAN NOW CRUSH

Q: What is hoisting? Give an example.
→ JS moves declarations to top. Ex: console.log(x); var x=5; → undefined (not error).

Q: Why ReferenceError with let but not var?
→ let has TDZ (uninitialized after hoist); var auto-initializes to undefined.

Q: Can you call a function before declaring it?
→ Yes, if Function Declaration (hoisted). No for expressions/arrows.

Q: What's TDZ?
→ Gap between 'let' hoist and init – variable "dead" (unusable).

Q: var x; console.log(x); → Output?
→ undefined (hoisted + auto-init).

Q: let x; console.log(x); → Output?
→ ReferenceError: Cannot access before initialization (TDZ).

================================================================================
PRACTICE ASSIGNMENT (Code This Now!)

1. Write code with var/let accessed before init → See undefined vs error.
2. Hoist a function call before declaration → Verify it works.
3. Add TDZ: Use let in a loop/conditional → Force error, then fix by moving init.
4. Trace on paper: GEC Creation vs Execution for mixed var/let/function code.

Example Starter:
console.log(x);     // ?
var x = 10;
console.log(y);     // ?
let y = 20;
greet();            // ?
function greet() { console.log("Hoisted!"); }

Run it → Predict/verify outputs!

================================================================================

Hoisting mastered → You're 10x clearer on JS execution!
Avoid 'var' forever (use let/const). Next: 'this' keyword, Closures, Scope.

Practice daily. Namaste – Keep shining!